<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioVisualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style type="text/tailwindcss">
        @layer base {
            body {
                @apply bg-zinc-950 text-zinc-100 font-sans overflow-hidden h-screen flex;
            }
        }
        input[type="range"] {
            @apply h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-indigo-500;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div id="sidebar" class="w-80 bg-zinc-900 border-r border-zinc-800 flex flex-col h-full overflow-y-auto shrink-0 p-6 space-y-6">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold tracking-tight text-indigo-400">AudioViz</h1>
            <div id="status" class="text-[10px] px-2 py-0.5 rounded-full bg-red-900/30 text-red-400 border border-red-800/50">Disconnected</div>
        </div>

        <!-- Controls -->
        <div class="space-y-4">
            <div class="control-group flex flex-col space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Volume</label>
                    <span id="volumeVal" class="text-xs text-indigo-400">1.0</span>
                </div>
                <input type="range" id="volume" min="0" max="2" step="0.1" value="1.0">
            </div>

            <div class="control-group flex flex-col space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Pitch</label>
                    <span id="pitchVal" class="text-xs text-indigo-400">1.0</span>
                </div>
                <input type="range" id="pitch" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="control-group flex flex-col space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Timescale</label>
                    <span id="timescaleVal" class="text-xs text-indigo-400">1.0</span>
                </div>
                <input type="range" id="timescale" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <hr class="border-zinc-800">

            <div class="control-group flex flex-col space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Modulation</label>
                    <span id="modFreqVal" class="text-xs text-indigo-400">0Hz</span>
                </div>
                <input type="range" id="modFreq" min="0" max="1000" step="10" value="0">
                <select id="modType" class="bg-zinc-800 border border-zinc-700 text-sm rounded-md px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                    <option value="ring">Ring Modulation</option>
                    <option value="am">Amplitude Modulation</option>
                </select>
            </div>

            <div class="control-group flex flex-col space-y-2">
                <div class="flex justify-between items-center">
                    <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Filters</label>
                </div>
                <div class="space-y-3">
                    <div class="flex flex-col space-y-1">
                        <div class="flex justify-between"><span class="text-[10px] text-zinc-500">LPF</span><span id="lpfVal" class="text-[10px] text-indigo-400">20k</span></div>
                        <input type="range" id="lpf" min="100" max="20000" step="500" value="20000">
                    </div>
                    <div class="flex flex-col space-y-1">
                        <div class="flex justify-between"><span class="text-[10px] text-zinc-500">HPF</span><span id="hpfVal" class="text-[10px] text-indigo-400">0</span></div>
                        <input type="range" id="hpf" min="0" max="10000" step="100" value="0">
                    </div>
                </div>
            </div>

            <hr class="border-zinc-800">

            <div class="control-group flex flex-col space-y-2">
                <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Appearance</label>
                <div class="grid grid-cols-2 gap-2">
                    <select id="colorProfile" class="bg-zinc-800 border border-zinc-700 text-xs rounded-md px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                        <option value="default">Default</option>
                    </select>
                    <select id="vizMode" class="bg-zinc-800 border border-zinc-700 text-xs rounded-md px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                        <option value="bars">Bars</option>
                        <option value="spectrogram">Spectrogram</option>
                        <option value="both">Both</option>
                    </select>
                </div>
            </div>

            <div class="control-group flex flex-col space-y-2">
                <label class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Source</label>
                <select id="audioFile" class="bg-zinc-800 border border-zinc-700 text-xs rounded-md px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500">
                    <option value="">Microphone</option>
                </select>
            </div>
        </div>

        <div class="mt-auto pt-6">
            <button id="recordBtn" class="w-full bg-zinc-800 hover:bg-zinc-700 text-white font-semibold py-2 px-4 rounded-md border border-zinc-700 transition-colors flex items-center justify-center space-x-2">
                <div id="recordDot" class="w-2 h-2 rounded-full bg-zinc-500"></div>
                <span>Start Recording</span>
            </button>
        </div>
    </div>

    <!-- Main Canvas -->
    <div class="flex-grow relative bg-black">
        <canvas id="canvas" class="w-full h-full"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const colorProfileSelect = document.getElementById('colorProfile');
        const audioFileSelect = document.getElementById('audioFile');
        
        let bars = [];
        let isBeat = false;
        const maxHistory = 400;
        let profiles = {};
        let config = {};
        let vizMode = 'bars';
        
        const spectrogramCanvas = document.createElement('canvas');
        const sCtx = spectrogramCanvas.getContext('2d');

        function resize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            spectrogramCanvas.width = canvas.width;
            spectrogramCanvas.height = maxHistory;
        }
        window.addEventListener('resize', resize);
        setTimeout(resize, 100);

        const ws = new WebSocket(`ws://${location.host}/ws`);
        
        ws.onopen = () => {
            status.textContent = 'Connected';
            status.className = 'text-[10px] px-2 py-0.5 rounded-full bg-green-900/30 text-green-400 border border-green-800/50';
            fetchFiles();
        };

        async function fetchFiles() {
            try {
                const resp = await fetch('/files');
                const data = await resp.json();
                audioFileSelect.innerHTML = '<option value="">Microphone</option>';
                data.files.forEach(f => {
                    const option = document.createElement('option');
                    option.value = f;
                    option.textContent = f;
                    audioFileSelect.appendChild(option);
                });
            } catch (e) {
                console.error("Failed to fetch files:", e);
            }
        }
        
        ws.onclose = () => {
            status.textContent = 'Disconnected';
            status.className = 'text-[10px] px-2 py-0.5 rounded-full bg-red-900/30 text-red-400 border border-red-800/50';
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'visualization') {
                bars = data.bars;
                isBeat = data.is_beat;
                updateRecordingUI(data.recording);
            } else if (data.type === 'init') {
                profiles = data.profiles;
                config = data.config;
                updateUI();
            } else if (data.type === 'config_update') {
                config = data.config;
                updateUI();
            }
        };

        function updateRecordingUI(isRecording) {
            const btn = document.getElementById('recordBtn');
            const dot = document.getElementById('recordDot');
            const span = btn.querySelector('span');
            if (isRecording) {
                btn.classList.add('bg-red-950', 'border-red-800', 'text-red-400');
                btn.classList.remove('bg-zinc-800');
                dot.classList.add('bg-red-500', 'animate-pulse');
                dot.classList.remove('bg-zinc-500');
                span.textContent = 'Stop Recording';
            } else {
                btn.classList.remove('bg-red-950', 'border-red-800', 'text-red-400');
                btn.classList.add('bg-zinc-800');
                dot.classList.remove('bg-red-500', 'animate-pulse');
                dot.classList.add('bg-zinc-500');
                span.textContent = 'Start Recording';
            }
        }

        function updateUI() {
            const controls = [
                { id: 'volume', key: 'processing.volume', suffix: '' },
                { id: 'pitch', key: 'processing.pitch', suffix: '' },
                { id: 'timescale', key: 'processing.timescale', suffix: '' },
                { id: 'modFreq', key: 'processing.modulation_freq', suffix: 'Hz' },
                { id: 'lpf', key: 'processing.lpf_cutoff', suffix: '' },
                { id: 'hpf', key: 'processing.hpf_cutoff', suffix: '' }
            ];

            controls.forEach(c => {
                const val = getNestedValue(config, c.key, 0);
                const el = document.getElementById(c.id);
                if (el) el.value = val;
                const valEl = document.getElementById(c.id + 'Val');
                if (valEl) valEl.textContent = typeof val === 'number' ? val.toFixed(c.suffix === 'Hz' ? 0 : 1) + c.suffix : val;
            });

            document.getElementById('modType').value = getNestedValue(config, 'processing.modulation_type', 'ring');
            
            const currentProfile = getNestedValue(config, 'terminal.color_profile', 'default');
            colorProfileSelect.innerHTML = '';
            for (const name in profiles) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                option.selected = (name === currentProfile);
                colorProfileSelect.appendChild(option);
            }

            const currentFile = getNestedValue(config, 'audio.file_path', '');
            for (let i = 0; i < audioFileSelect.options.length; i++) {
                if (audioFileSelect.options[i].value === currentFile) {
                    audioFileSelect.selectedIndex = i;
                    break;
                }
            }
        }

        function getNestedValue(obj, key, defaultValue) {
            const keys = key.split('.');
            let val = obj;
            for (const k of keys) {
                if (val && typeof val === 'object' && k in val) {
                    val = val[k];
                } else {
                    return defaultValue;
                }
            }
            return val !== undefined ? val : defaultValue;
        }

        function getInterpolatedColor(colors, pos) {
            if (!colors || colors.length === 0) return 'white';
            if (colors.length === 1) return colors[0];
            
            const idx = Math.min(Math.floor(pos * (colors.length - 1)), colors.length - 2);
            const localPos = (pos * (colors.length - 1)) - idx;
            
            const c1 = hexToRgb(colors[idx]);
            const c2 = hexToRgb(colors[idx+1]);
            
            const r = Math.round(c1.r * (1 - localPos) + c2.r * localPos);
            const g = Math.round(c1.g * (1 - localPos) + c2.g * localPos);
            const b = Math.round(c1.b * (1 - localPos) + c2.b * localPos);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        function draw() {
            ctx.fillStyle = isBeat ? '#0a0a1a' : '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (bars.length === 0) {
                requestAnimationFrame(draw);
                return;
            }

            const isMultiChannel = Array.isArray(bars[0]);
            const currentBars = isMultiChannel ? bars[0] : bars;
            const profileName = getNestedValue(config, 'terminal.color_profile', 'default');
            const profile = profiles[profileName] || { type: 'frequency', colors: ['#ffffff'] };

            // Update Spectrogram Offscreen
            const imgData = sCtx.getImageData(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
            sCtx.putImageData(imgData, 0, 1); 
            
            const barWidth = spectrogramCanvas.width / currentBars.length;
            const maxVal = Math.max(...currentBars, 1);
            
            currentBars.forEach((val, i) => {
                const intensity = val / maxVal;
                if (profile.type === 'solid') {
                    sCtx.fillStyle = profile.color || profile.colors[0];
                    sCtx.globalAlpha = intensity;
                } else {
                    sCtx.fillStyle = getInterpolatedColor(profile.colors, i / (currentBars.length - 1));
                    sCtx.globalAlpha = intensity;
                }
                sCtx.fillRect(i * barWidth, 0, barWidth + 1, 1);
                sCtx.globalAlpha = 1.0;
            });

            if (vizMode === 'bars' || vizMode === 'both') {
                const drawHeight = vizMode === 'both' ? canvas.height / 2 : canvas.height;
                const channels = isMultiChannel ? bars : [bars];
                const numChannels = channels.length;
                const channelHeight = drawHeight / numChannels;

                channels.forEach((channelBars, cIdx) => {
                    const bWidth = canvas.width / channelBars.length;
                    const mVal = Math.max(...channelBars, 1);
                    const yOffset = cIdx * channelHeight;

                    channelBars.forEach((val, i) => {
                        let barHeight = (val / mVal) * channelHeight;
                        if (isBeat) barHeight *= 1.1; // Pulse on beat
                        
                        if (profile.type === 'solid') {
                            ctx.fillStyle = profile.color || profile.colors[0];
                        } else if (profile.type === 'amplitude') {
                            ctx.fillStyle = getInterpolatedColor(profile.colors, val / mVal);
                        } else { // frequency / gradient
                            ctx.fillStyle = getInterpolatedColor(profile.colors, i / (channelBars.length - 1));
                        }
                        
                        ctx.fillRect(i * bWidth, yOffset + channelHeight - barHeight, bWidth - 1, barHeight);
                    });
                });
            }

            if (vizMode === 'spectrogram' || vizMode === 'both') {
                const drawHeight = vizMode === 'both' ? canvas.height / 2 : canvas.height;
                const yOffset = vizMode === 'both' ? canvas.height / 2 : 0;
                ctx.drawImage(spectrogramCanvas, 0, 0, spectrogramCanvas.width, spectrogramCanvas.height, 0, yOffset, canvas.width, drawHeight);
            }

            requestAnimationFrame(draw);
        }
        draw();

        // Control handlers
        const sendUpdate = (key, val) => {
            ws.send(JSON.stringify({ type: 'config_update', data: { [key]: val } }));
        };

        document.getElementById('volume').oninput = (e) => sendUpdate('processing.volume', parseFloat(e.target.value));
        document.getElementById('pitch').oninput = (e) => sendUpdate('processing.pitch', parseFloat(e.target.value));
        document.getElementById('timescale').oninput = (e) => sendUpdate('processing.timescale', parseFloat(e.target.value));
        document.getElementById('modFreq').oninput = (e) => sendUpdate('processing.modulation_freq', parseFloat(e.target.value));
        document.getElementById('modType').onchange = (e) => sendUpdate('processing.modulation_type', e.target.value);
        document.getElementById('lpf').oninput = (e) => sendUpdate('processing.lpf_cutoff', parseFloat(e.target.value));
        document.getElementById('hpf').oninput = (e) => sendUpdate('processing.hpf_cutoff', parseFloat(e.target.value));
        document.getElementById('recordBtn').onclick = (e) => ws.send(JSON.stringify({ type: 'toggle_recording' }));
        colorProfileSelect.onchange = (e) => sendUpdate('terminal.color_profile', e.target.value);
        document.getElementById('vizMode').onchange = (e) => {
            vizMode = e.target.value;
            sCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
        };
        audioFileSelect.onchange = (e) => {
            sendUpdate('audio.file_path', e.target.value);
            sendUpdate('audio.input_type', e.target.value ? 'file' : 'microphone');
        };
    </script>
</body>
</html>
