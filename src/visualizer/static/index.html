<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioVisualizer</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: #eee;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #canvas {
            flex-grow: 1;
            width: 100%;
        }
        #controls {
            padding: 10px;
            background: #222;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-size: 12px;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label>Volume</label>
            <input type="range" id="volume" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Pitch</label>
            <input type="range" id="pitch" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Timescale</label>
            <input type="range" id="timescale" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Modulation Freq</label>
            <input type="range" id="modFreq" min="0" max="1000" step="10" value="0">
        </div>
        <div class="control-group">
            <label>Mod Type</label>
            <select id="modType">
                <option value="ring">Ring</option>
                <option value="am">AM</option>
            </select>
        </div>
        <div class="control-group">
            <label>LPF Cutoff</label>
            <input type="range" id="lpf" min="100" max="20000" step="500" value="20000">
        </div>
        <div class="control-group">
            <label>HPF Cutoff</label>
            <input type="range" id="hpf" min="0" max="10000" step="100" value="0">
        </div>
        <div class="control-group">
            <label>Color Profile</label>
            <select id="colorProfile">
                <option value="default">Default</option>
            </select>
        </div>
        <div class="control-group">
            <label>Viz Mode</label>
            <select id="vizMode">
                <option value="bars">Bars</option>
                <option value="spectrogram">Spectrogram</option>
                <option value="both">Both</option>
            </select>
        </div>
        <div class="control-group">
            <label>Audio File</label>
            <select id="audioFile">
                <option value="">None</option>
            </select>
        </div>
        <div class="control-group">
            <label>Record</label>
            <button id="recordBtn" style="background: #444; color: white; border: none; padding: 5px 10px; cursor: pointer;">Record</button>
        </div>
        <div id="status">Disconnected</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const colorProfileSelect = document.getElementById('colorProfile');
        const audioFileSelect = document.getElementById('audioFile');
        
        let bars = [];
        let history = [];
        const maxHistory = 400;
        let profiles = {};
        let config = {};
        let vizMode = 'bars';
        
        const spectrogramCanvas = document.createElement('canvas');
        const sCtx = spectrogramCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.getElementById('controls').offsetHeight;
            spectrogramCanvas.width = canvas.width;
            spectrogramCanvas.height = maxHistory;
        }
        window.addEventListener('resize', resize);
        resize();

        const ws = new WebSocket(`ws://${location.host}/ws`);
        
        ws.onopen = () => {
            status.textContent = 'Connected';
            status.style.color = 'green';
            fetchFiles();
        };

        async function fetchFiles() {
            try {
                const resp = await fetch('/files');
                const data = await resp.json();
                audioFileSelect.innerHTML = '<option value="">Select File...</option>';
                data.files.forEach(f => {
                    const option = document.createElement('option');
                    option.value = f;
                    option.textContent = f;
                    audioFileSelect.appendChild(option);
                });
            } catch (e) {
                console.error("Failed to fetch files:", e);
            }
        }
        
        ws.onclose = () => {
            status.textContent = 'Disconnected';
            status.style.color = 'red';
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'visualization') {
                bars = data.bars;
                updateRecordingUI(data.recording);
            } else if (data.type === 'init') {
                profiles = data.profiles;
                config = data.config;
                updateUI();
            } else if (data.type === 'config_update') {
                config = data.config;
                updateUI();
            }
        };

        function updateRecordingUI(isRecording) {
            const btn = document.getElementById('recordBtn');
            if (isRecording) {
                btn.style.backgroundColor = 'red';
                btn.textContent = 'Stop Recording';
            } else {
                btn.style.backgroundColor = '#444';
                btn.textContent = 'Record';
            }
        }

        function updateUI() {
            // Update sliders
            document.getElementById('volume').value = getNestedValue(config, 'processing.volume', 1.0);
            document.getElementById('pitch').value = getNestedValue(config, 'processing.pitch', 1.0);
            document.getElementById('timescale').value = getNestedValue(config, 'processing.timescale', 1.0);
            document.getElementById('modFreq').value = getNestedValue(config, 'processing.modulation_freq', 0);
            document.getElementById('modType').value = getNestedValue(config, 'processing.modulation_type', 'ring');
            document.getElementById('lpf').value = getNestedValue(config, 'processing.lpf_cutoff', 20000);
            document.getElementById('hpf').value = getNestedValue(config, 'processing.hpf_cutoff', 0);
            
            // Update profile selector
            const currentProfile = getNestedValue(config, 'terminal.color_profile', 'default');
            colorProfileSelect.innerHTML = '';
            for (const name in profiles) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                option.selected = (name === currentProfile);
                colorProfileSelect.appendChild(option);
            }

            // Update file selector
            const currentFile = getNestedValue(config, 'audio.file_path', '');
            for (let i = 0; i < audioFileSelect.options.length; i++) {
                if (audioFileSelect.options[i].value === currentFile) {
                    audioFileSelect.selectedIndex = i;
                    break;
                }
            }
        }

        function getNestedValue(obj, key, defaultValue) {
            const keys = key.split('.');
            let val = obj;
            for (const k of keys) {
                if (val && typeof val === 'object' && k in val) {
                    val = val[k];
                } else {
                    return defaultValue;
                }
            }
            return val !== undefined ? val : defaultValue;
        }

        function getInterpolatedColor(colors, pos) {
            if (!colors || colors.length === 0) return 'white';
            if (colors.length === 1) return colors[0];
            
            const idx = Math.min(Math.floor(pos * (colors.length - 1)), colors.length - 2);
            const localPos = (pos * (colors.length - 1)) - idx;
            
            const c1 = hexToRgb(colors[idx]);
            const c2 = hexToRgb(colors[idx+1]);
            
            const r = Math.round(c1.r * (1 - localPos) + c2.r * localPos);
            const g = Math.round(c1.g * (1 - localPos) + c2.g * localPos);
            const b = Math.round(c1.b * (1 - localPos) + c2.b * localPos);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (bars.length === 0) {
                requestAnimationFrame(draw);
                return;
            }

            const isMultiChannel = Array.isArray(bars[0]);
            const currentBars = isMultiChannel ? bars[0] : bars;
            const profileName = getNestedValue(config, 'terminal.color_profile', 'default');
            const profile = profiles[profileName] || { type: 'frequency', colors: ['#ffffff'] };

            // Update Spectrogram Offscreen
            const imgData = sCtx.getImageData(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
            sCtx.putImageData(imgData, 0, 1); // Shift down
            
            const barWidth = spectrogramCanvas.width / currentBars.length;
            const maxVal = Math.max(...currentBars, 1);
            
            currentBars.forEach((val, i) => {
                const intensity = val / maxVal;
                if (profile.type === 'solid') {
                    sCtx.fillStyle = profile.color || profile.colors[0];
                    sCtx.globalAlpha = intensity;
                } else {
                    sCtx.fillStyle = getInterpolatedColor(profile.colors, i / (currentBars.length - 1));
                    sCtx.globalAlpha = intensity;
                }
                sCtx.fillRect(i * barWidth, 0, barWidth + 1, 1);
                sCtx.globalAlpha = 1.0;
            });

            if (vizMode === 'bars' || vizMode === 'both') {
                const drawHeight = vizMode === 'both' ? canvas.height / 2 : canvas.height;
                const channels = isMultiChannel ? bars : [bars];
                const numChannels = channels.length;
                const channelHeight = drawHeight / numChannels;

                channels.forEach((channelBars, cIdx) => {
                    const bWidth = canvas.width / channelBars.length;
                    const mVal = Math.max(...channelBars, 1);
                    const yOffset = cIdx * channelHeight;

                    channelBars.forEach((val, i) => {
                        const barHeight = (val / mVal) * channelHeight;
                        
                        if (profile.type === 'solid') {
                            ctx.fillStyle = profile.color || profile.colors[0];
                        } else if (profile.type === 'amplitude') {
                            ctx.fillStyle = getInterpolatedColor(profile.colors, val / mVal);
                        } else { // frequency / gradient
                            ctx.fillStyle = getInterpolatedColor(profile.colors, i / (channelBars.length - 1));
                        }
                        
                        ctx.fillRect(i * bWidth, yOffset + channelHeight - barHeight, bWidth - 1, barHeight);
                    });
                });
            }

            if (vizMode === 'spectrogram' || vizMode === 'both') {
                const drawHeight = vizMode === 'both' ? canvas.height / 2 : canvas.height;
                const yOffset = vizMode === 'both' ? canvas.height / 2 : 0;
                ctx.drawImage(spectrogramCanvas, 0, 0, spectrogramCanvas.width, spectrogramCanvas.height, 0, yOffset, canvas.width, drawHeight);
            }

            requestAnimationFrame(draw);
        }
        draw();

        // Control handlers
        document.getElementById('volume').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.volume': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('pitch').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.pitch': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('timescale').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.timescale': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('modFreq').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.modulation_freq': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('modType').onchange = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.modulation_type': e.target.value }
            }));
        };
        document.getElementById('lpf').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.lpf_cutoff': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('hpf').oninput = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'processing.hpf_cutoff': parseFloat(e.target.value) }
            }));
        };
        document.getElementById('recordBtn').onclick = (e) => {
            ws.send(JSON.stringify({
                type: 'toggle_recording'
            }));
        };
        colorProfileSelect.onchange = (e) => {
            ws.send(JSON.stringify({
                type: 'config_update',
                data: { 'terminal.color_profile': e.target.value }
            }));
        };
        document.getElementById('vizMode').onchange = (e) => {
            vizMode = e.target.value;
            sCtx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
        };
        audioFileSelect.onchange = (e) => {
            if (e.target.value) {
                ws.send(JSON.stringify({
                    type: 'config_update',
                    data: { 
                        'audio.file_path': e.target.value,
                        'audio.input_type': 'file'
                    }
                }));
            }
        };
    </script>
</body>
</html>